import { app, BrowserWindow, Menu, dialog, ipcMain } from 'electron';
import fs from 'fs';
import path from 'path';

import { MidiFile } from './electron/midifile';
// import Database from '../db_old/db_connector';
import MusicLLMinstance from './electron/ollama/ollama';
import { getLLMUserPrompt } from './electron/ollama/llm_prompt_builder';
import { getTopListForParams } from './electron/musicbrainz/musicbrainz';
import { json } from 'stream/consumers';
import { getDbEntryForHash, initMongo, saveMidiDocument, searchMidiDocuments } from './electron/mongo/mongo';
import { IDBMidiDocument } from './electron/mongo/global';
import { dir } from 'console';
import { get } from 'http';
import { SearchMidiDocumentsResult } from './web/MidiSearch';


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let enableFileLog: boolean = false;
let logStack: any = [];
let orgiginalConsoleLog: any = console.log;

console.log = function (...args) {
    if (enableFileLog) {
        logStack.push(args.join(" "));
    }
    // if (args.join(" ").includes("link: undefined")) {
    //     console.error("link: undefined");
    // }
    orgiginalConsoleLog("electron main: ", ...args);
}
global.console = console;

const logFile = path.join(__dirname, "../log.txt");
//fs.writeFileSync(logFile, '', { encoding: 'utf8' });

let logInterval: any = undefined;
function enableElectronFileLog(enable: boolean) {
    enableFileLog = enable;
    if (enable) {
        logStack.push("File logging enabled");
        logInterval = setInterval(() => {
            if (enableFileLog && logStack.length > 0) {
                fs.appendFile(logFile, logStack.join("\n"), (err) => {
                    if (err) {
                        console.error("Error writing log file: ", err);
                    }
                });
                logStack = [];
            }
        }, 5000);
    }
    else {
        if (logInterval) {
            clearInterval(logInterval);
            logInterval = undefined;
        }
    }
}

enableElectronFileLog(true);


// const database = new Database();

// (async () => {
//     await database.initializeTables();
//     if (!database.isInitialized()) {
//         console.error('Database is not initialized. Exiting application.');
//         app.quit();
//     }
// })();
(async () => {
    // Initialize mongoDB
    await initMongo();
})();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

const createWindow = (): void => {
    // Create the browser window.
    const mainWindow = new BrowserWindow({
        height: 1000,
        width: 1200,
        webPreferences: {
            //nodeIntegration: true,,
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    // mainWindow.webContents.openDevTools();

    // Set up the custom menu
    const menu = Menu.buildFromTemplate([
        {
            label: app.name, // App-Name als Menüeintrag (Standard auf macOS)
            submenu: [
                {
                    label: 'Reload UI',
                    accelerator: 'CmdOrCtrl+R', // Shortcut für Command + R
                    role: 'reload', // Standardaktion für Reload
                },
                {
                    label: 'Beenden',
                    accelerator: 'CmdOrCtrl+Q', // Shortcut für Command + Q
                    click: () => {
                        app.quit(); // Beendet die App
                    },
                },
            ],
        },
        {
            label: "Edit",
            submenu: [
                { label: "Undo", accelerator: "CmdOrCtrl+Z", role: "undo" },
                { label: "Redo", accelerator: "Shift+CmdOrCtrl+Z", role: "redo" },
                { type: "separator" },
                { label: "Cut", accelerator: "CmdOrCtrl+X", role: "cut" },
                { label: "Copy", accelerator: "CmdOrCtrl+C", role: "copy" },
                { label: "Paste", accelerator: "CmdOrCtrl+V", role: "paste" },
                { label: "Select All", accelerator: "CmdOrCtrl+A", role: "selectAll" }
            ]
        },
        {
            label: 'Datei',
            submenu: [
                {
                    label: 'Ordner importieren',
                    click: async () => {
                        const result = await dialog.showOpenDialog(mainWindow, {
                            properties: ['openDirectory'],
                        });
                        if (!result.canceled && result.filePaths.length > 0) {
                            console.log('Ordner importiert:', result.filePaths[0]);
                            // Hier kannst du die Logik für den Ordner-Import hinzufügen
                        }
                    },
                },
                {
                    label: 'Datei öffnen',
                    click: async () => {
                        const result = await dialog.showOpenDialog(mainWindow, {
                            properties: ['openFile'],
                        });
                        if (!result.canceled && result.filePaths.length > 0) {
                            console.log('Datei geöffnet:', result.filePaths[0]);
                            // Hier kannst du die Logik für das Öffnen der Datei hinzufügen
                        }
                    },
                },
                {
                    label: 'Debugger umschalten',
                    click: () => {
                        if (mainWindow.webContents.isDevToolsOpened()) {
                            mainWindow.webContents.closeDevTools();
                        } else {
                            mainWindow.webContents.openDevTools();
                        }
                    },
                },
            ],
        },
    ]);

    Menu.setApplicationMenu(menu);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.


// Hilfsfunktion: Alle .mid und .kar Dateien rekursiv finden
function findMidiFiles(dir: string, fileList: string[] = []): string[] {
    const files = fs.readdirSync(dir);
    for (const file of files) {
        const fullPath = path.join(dir, file);
        const stat = fs.statSync(fullPath);
        if (stat.isDirectory()) {
            findMidiFiles(fullPath, fileList);
        } else if (stat.isFile() && (file.toLowerCase().endsWith('.mid') || file.toLowerCase().endsWith('.kar'))) {
            fileList.push(fullPath);
        }
    }
    return fileList;
}

async function parseDirectory(directory: string): Promise<void> {
    console.log('Selected directory:', directory);
    // Hier kannst du die Logik für das Scannen des Verzeichnisses hinzufügen
    // Beispiel: Alle MIDI-Dateien im Verzeichnis auflisten
    // Alle MIDI-Dateien rekursiv finden
    const midiFiles = findMidiFiles(directory);
    console.log(`Gefundene MIDI-Dateien: ${midiFiles.length}`);

    // Für jede Datei: lesen und speichern
    let processedFiles = 0;
    let insertedFiles = 0;
    let errorFiles = 0;
    let doubles = 0;
    for (const midiPath of midiFiles) {
        const start = Date.now();
        try {
            let ret: IMidiFileInformation = {
                midifile: null,
                musicLLM: null,
                musicbrainz: null,
                validationState: 'open'
            };

            processedFiles++;
            ret.midifile = await readMidiFile(midiPath);
            if (ret.midifile === null) {
                console.log('MidiPath not exists:', midiPath);
                continue;
            }

            let db_document: IDBMidiDocument | null = ret.midifile ? await getDbEntryForHash(ret.midifile.hash) : null;
            // check if name is in db entry
            if (db_document && db_document.midifile.fileName) {
                let f_name_to_search = ret.midifile.fileName ? ret.midifile.fileName[0] : "";
                let fileNames = db_document.midifile.fileName;
                if (fileNames.includes(f_name_to_search)) {
                    // f_name_to_search ist bereits vorhanden
                    doubles++;
                    console.log('File already in database:', f_name_to_search);
                    continue; // hash already in db
                }
                else {
                    ret.midifile.fileName = [...fileNames, f_name_to_search];
                }
            }

            ret.musicLLM = await parseWithOLLAMA(ret.midifile);
            ret.musicbrainz = await parseOnMusicbrainz(ret.musicLLM, ret.midifile);
            ret = validationStateMidiFile(ret);

            try {
                await saveMidiDocument(<IDBMidiDocument>ret);
                insertedFiles++;
            }
            catch (err) {
                errorFiles++;
                console.error('Fehler beim Speichern der MIDI-Datei:', err);
                fs.appendFileSync('error.log', `Fehler beim Speichern der MIDI-Datei ${midiPath}:\n ${err}\n\n\n`);
            }


        }
        catch (err) {
            errorFiles++;
            console.error(`Fehler bei Datei ${midiPath}:`, err);
            fs.appendFileSync('error.log', `Fehler bei Datei ${midiPath}:\n ${err}\n\n\n`);
        }
        const duration = Date.now() - start;
        // console.log('\nHeap used:', Math.round(process.memoryUsage().heapUsed / 1024 / 1024), 'MB');
        console.error(`Midifile parsing/saving Dauer: \t\t${duration} ms`);
        console.error(`Verarbeitet: ${processedFiles}, Eingefügt: ${insertedFiles}, Fehler: ${errorFiles}, Duplikate: ${doubles}`);
    }
    console.log(`Verarbeitet: ${processedFiles}, Eingefügt: ${insertedFiles}, Fehler: ${errorFiles}, Duplikate: ${doubles}`);
}

ipcMain.handle('start-scan-dir', async (): Promise<void> => {
    const result = await dialog.showOpenDialog({
        properties: ['openDirectory'],
        message: 'Select a directory to scan for MIDI files'
    });
    if (result.canceled) {
        console.log('Directory selection canceled');
        return;
    }
    else {
        const selectedDirectory = result.filePaths[0];
        parseDirectory(selectedDirectory)
            .then(() => {
                console.log('Directory scan completed');
            })
            .catch((err) => {
                console.error('Error during directory scan:', err);
            });
    }
});

async function readMidiFile(filePath: string): Promise<ILoadMidiFile | null> {
    if (filePath) {

        let midifile = <ILoadMidiFile>MidiFile.openMidiFile(filePath)?.toJSON();
        return midifile;
    }
    return null;
}
async function parseWithOLLAMA(midiFile: ILoadMidiFile): Promise<IMusicLLM_softsearch_result | null> {
    // check data with ollama
    let musicllm = null;
    if (midiFile) {
        //const start = Date.now();
        musicllm = await MusicLLMinstance.soft_search(getLLMUserPrompt(midiFile));
        //const duration = Date.now() - start;
        //console.log(`MusicLLMinstance.soft_search Dauer: ${duration} ms`);
        // musicllm = await MusicLLMinstance.soft_search(getLLMUserPrompt(midifile.toJSON()));
    }
    return musicllm;
}

async function parseOnMusicbrainz(musicllm: IMusicLLM_softsearch_result | null, midifile: ILoadMidiFile | null): Promise<IMusicbrainzResponse | null> {

    // check data with ollama
    if (midifile) {
        //const start = Date.now();
        musicllm = await MusicLLMinstance.soft_search(getLLMUserPrompt(midifile));
        //const duration = Date.now() - start;
        //console.log(`MusicLLMinstance.soft_search Dauer: ${duration} ms`);
        // musicllm = await MusicLLMinstance.soft_search(getLLMUserPrompt(midifile.toJSON()));
    }

    //const start = Date.now();
    // musicbrainz lookup
    let musicbrainz = await getTopListForParams({
        title: musicllm?.title ? musicllm.title : (midifile?.fileName ? midifile?.fileName[0] : ""),
        artist: musicllm?.artist ? musicllm.artist : null,
        release: musicllm?.release ? musicllm.release : null,
        album: musicllm?.album ? musicllm.album : null
    }, 3);
    //const duration = Date.now() - start;
    //console.log(`getTopListForParams Dauer: ${duration} ms`);
    //console.log('musicbrainz:', musicbrainz);
    return musicbrainz;
}


function validationStateMidiFile(midiFileInformation: IMidiFileInformation): IMidiFileInformation {
    if (midiFileInformation.musicLLM
        && midiFileInformation.musicbrainz
        && midiFileInformation.musicbrainz.top
        && midiFileInformation.musicbrainz.top.length > 0) {
        midiFileInformation.validationState = 'open';
    }
    else if (!midiFileInformation.musicLLM
        || !midiFileInformation.musicbrainz
        || !midiFileInformation.musicbrainz.top
        || midiFileInformation.musicbrainz.top.length === 0) {
        midiFileInformation.validationState = 'review';
    }
    return midiFileInformation;
}


ipcMain.handle("get-midi-file-by-hash", async (_event, hash: string): Promise<IMidiFileInformation | null> => {
    //console.log('get-midi-file-by-hash:', hash);
    let db_document: IDBMidiDocument | null = await getDbEntryForHash(hash);
    if (db_document) {
        //console.log('get-midi-file-by-hash:', db_document);
        let ret: IMidiFileInformation = {
            midifile: db_document.midifile,
            musicLLM: db_document.musicLLM,
            musicbrainz: db_document.musicbrainz,
            validationState: db_document.validationState
        };
        //console.log('get-midi-file-by-hash:', ret);
        return ret;
    }
    else {
        console.log('get-midi-file-by-hash: not found');
        return null;
    }
});


ipcMain.handle('save-midi-file', async (_event, midi: IMidiFileInformation): Promise<void> => {
    //console.log('save-midi-file:', midi);
    if (midi) {
        try {
            let db_document: IDBMidiDocument = midi as IDBMidiDocument;
            await saveMidiDocument(db_document);
        }
        catch (err) {
            console.error('Fehler beim Speichern der MIDI-Datei:', err);
        }
    }
});


ipcMain.handle('search-midi-document', async (_event, arg0: { $text: { $search: string; } }, $skip: number, $limit: number): Promise<SearchMidiDocumentsResult> => {
    //console.log('search-midi-document:', searchParams);
    // { $text: { $search: string; }; $skip: number; $limit: number; }
    let docs = await searchMidiDocuments(arg0, $skip, $limit);
    return docs;
});


ipcMain.handle('open-midi-file', async (): Promise<IMidiFileInformation | null> => {
    const { filePaths } = await dialog.showOpenDialog({
        properties: ['openFile'],
        filters: [{ name: 'MIDI Files', extensions: ['mid', 'midi'] }]
    });
    try {
        if (filePaths[0]) {
            let ret: IMidiFileInformation = {
                midifile: null,
                musicLLM: null,
                musicbrainz: null,
                validationState: 'open'
            };
            ret.midifile = (await readMidiFile(filePaths[0]));
            if (ret.midifile === null) {
                return null; // hash already in db
            }

            //console.log('ret:', JSON.stringify(ret));
            let db_document: IDBMidiDocument | null = ret.midifile ? await getDbEntryForHash(ret.midifile.hash) : null;
            // check if name is in db entry
            if (db_document && db_document.midifile.fileName) {
                let f_name_to_search = ret.midifile.fileName ? ret.midifile.fileName[0] : "";
                let fileNames = db_document.midifile.fileName;
                if (fileNames.includes(f_name_to_search)) {
                    // f_name_to_search ist bereits vorhanden
                    return db_document; // hash already in db
                }
                else {
                    ret.midifile.fileName = [...fileNames, f_name_to_search];
                }
            }

            ret.musicLLM = await parseWithOLLAMA(ret.midifile);
            ret.musicbrainz = await parseOnMusicbrainz(ret.musicLLM, ret.midifile);

            ret = validationStateMidiFile(ret);

            // saveMidiDocument(<IDBMidiDocument>ret); // save to DB

            // generate DB entry
            // console.log('ret:', JSON.stringify(ret));
            return ret; // Hier wird die Methode toJSON() aufgerufen
        }
    }

    catch (err) {
        console.error('Fehler beim Laden der MIDI-Datei:', err);
    }
    return null;
});

ipcMain.handle('load-soundfont', async (_event, soundfontName: string) => {
    try {
        // const soundfontPath = app.isPackaged
        //     ? path.join(process.resourcesPath, 'soundfont', soundfontName)
        //     : path.join(__dirname, '../soundfont', soundfontName);
        // Absoluten Pfad ermitteln, falls nötig
        const exePath = app.getPath('exe');
        let resolvedPath = path.join(exePath, "soundfont", soundfontName);
        if (!fs.existsSync(resolvedPath)) {
            resolvedPath = path.join(exePath, "../../../../../../..", "soundfont", soundfontName);
            if (!fs.existsSync(resolvedPath)) {
                resolvedPath = path.join(exePath, "../../../..", "soundfont", soundfontName);
                if (!fs.existsSync(resolvedPath)) {
                    console.error('Soundfont not found:', resolvedPath);
                    return resolvedPath;
                }
            }
        }
        const data = fs.readFileSync(resolvedPath);
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength); // ArrayBuffer
    } catch (err) {
        console.error('Fehler beim Laden des Soundfonts:', err);
        return null;
    }
});


ipcMain.handle('get-midi-document-by-hash', async (_event, hash: string) => {
    //console.log('get-midi-document-by-hash:', hash);
    let db_document: IDBMidiDocument | null = await getDbEntryForHash(hash);
    if (db_document) {
        //console.log('get-midi-document-by-hash:', db_document);
        let ret: IMidiFileInformation = {
            midifile: db_document.midifile,
            musicLLM: db_document.musicLLM,
            musicbrainz: db_document.musicbrainz,
            validationState: db_document.validationState
        };
        //console.log('get-midi-document-by-hash:', ret);
        return ret;
    }
    else {
        console.log('get-midi-document-by-hash: not found');
        return null;
    }
});
